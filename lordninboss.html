<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lordnine: Boss Raid Timer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Phosphor Icons for a clean, modern look -->
    <script src="https://unpkg.com/@phosphor-icons/web@2.0.3/dist/p-icons.min.js"></script>
    <style>
        :root {
            --primary-bg: #111827; /* Darkest Blue-Gray */
            --card-bg: #1f2937; /* Dark Gray */
            --accent-color: #2dd4bf; /* Teal */
            --light-text: #f3f4f6;
            font-family: 'Inter', sans-serif;
        }
        body {
            background-color: var(--primary-bg);
            color: var(--light-text);
        }
        .card {
            background-color: var(--card-bg);
            border: 1px solid rgba(45, 212, 191, 0.1);
        }
        input[type="datetime-local"] {
            color-scheme: dark;
        }
        .tab-button {
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }
        .tab-button.active {
            border-bottom-color: var(--accent-color);
            color: var(--accent-color);
        }
        .btn-accent {
            background-image: linear-gradient(90deg, #10b981, #2dd4bf);
            transition: all 0.2s ease-in-out;
        }
        .btn-accent:hover {
            box-shadow: 0 4px 15px rgba(45, 212, 191, 0.4);
            transform: translateY(-1px);
        }
        /* Style for action buttons */
        .action-btn {
            transition: color 0.2s, background-color 0.2s;
            border-radius: 6px;
        }
        /* Style for the Set Killed button */
        .set-killed-btn {
            color: #2dd4bf; /* Teal color */
            border: 1px solid #2dd4bf44;
        }
        .set-killed-btn:hover {
            background-color: #2dd4bf33;
            color: #2dd4bf;
        }
        .delete-btn:hover {
            background-color: #ef444433;
            color: #ef4444;
        }
        .result-row:hover {
            background-color: #2c3a4e; /* Slightly lighter hover for visibility */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-4xl mx-auto space-y-8">
        <!-- Header -->
        <h1 class="text-4xl md:text-5xl font-extrabold text-center tracking-tight">
            <span class="text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-teal-400">LORDNINE</span> Boss Timer
        </h1>
        <p class="text-center text-gray-400">Track and share raid respawn schedules in real-time.</p>

        <!-- Main Card -->
        <div class="card p-4 md:p-6 rounded-xl shadow-2xl">
            <!-- Tabs -->
            <div class="flex border-b border-gray-700 mb-6">
                <button id="tabAdd" class="tab-button active flex-1 py-3 text-lg font-semibold text-center focus:outline-none">
                    <i class="ph ph-timer"></i> Add New Timer
                </button>
                <button id="tabList" class="tab-button flex-1 py-3 text-lg font-semibold text-center focus:outline-none">
                    <i class="ph ph-list-checks"></i> Scheduled Bosses
                </button>
            </div>

            <!-- Content Container -->
            <div id="contentContainer">
                <!-- 1. Add Timer Form (Default View) -->
                <div id="viewAdd" class="space-y-6">
                    <div>
                        <label for="bossName" class="block text-sm font-medium mb-2 text-gray-300">Boss Name</label>
                        <input type="text" id="bossName" placeholder="e.g., The Lich King" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-teal-500 focus:border-teal-500 transition duration-150" required>
                    </div>
                    
                    <div>
                        <label for="timeOfDeath" class="block text-sm font-medium mb-2 text-gray-300">Time of Death (TOD)</label>
                        <input type="datetime-local" id="timeOfDeath" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-teal-500 focus:border-teal-500 transition duration-150" required>
                    </div>

                    <div>
                        <label for="respawnInterval" class="block text-sm font-medium mb-2 text-gray-300">Fixed Respawn Cycle (Hours)</label>
                        <input type="number" id="respawnInterval" min="1" step="1" placeholder="e.g., 24, 48, 72" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-teal-500 focus:border-teal-500 transition duration-150" required>
                    </div>

                    <button id="addTimerBtn" class="btn-accent w-full py-3 rounded-lg text-lg font-bold text-gray-900 shadow-md">
                        <i class="ph ph-plus-circle"></i> Save Boss Timer
                    </button>
                    
                    <!-- Form Message/Error Box -->
                    <div id="formMessage" class="hidden text-center p-3 rounded-lg font-medium"></div>
                </div>

                <!-- 2. Scheduled Bosses List (Hidden by default) -->
                <div id="viewList" class="hidden">
                    <p id="loadingIndicator" class="text-center text-gray-500 mb-4"><i class="ph ph-circle-notch animate-spin mr-2"></i> Loading boss schedules...</p>
                        
                    <!-- Bosses Table -->
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead>
                                <tr class="text-left text-sm font-medium text-gray-400">
                                    <th class="py-3 pr-2">Boss</th>
                                    <th class="py-3 px-2 hidden lg:table-cell">TOD</th>
                                    <th class="py-3 px-2">Spawn Time</th>
                                    <th class="py-3 px-2 text-center">Status</th> 
                                    <th class="py-3 px-2 text-center">Remaining</th>
                                    <th class="py-3 pl-2 w-32 text-center">Actions</th> 
                                </tr>
                            </thead>
                            <tbody id="bossListBody" class="divide-y divide-gray-800">
                                <!-- Boss items will be injected here -->
                            </tbody>
                        </table>
                    </div>

                    <p id="noBossesMessage" class="hidden text-center text-gray-500 mt-4">No bosses scheduled yet. Add one!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Imports and Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, deleteDoc, doc, updateDoc, query, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set log level to Debug for visibility
        setLogLevel('Debug');

        // --- 1. Global Variables & Setup ---
        
        // Mandatory global variables for Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db;
        let auth;
        // currentUserId is no longer needed as a user-facing concept
        let realtimeTimerInterval = null;
        const bossesCollectionPath = `/artifacts/${appId}/public/data/boss_timers`;

        // DOM elements
        const tabAdd = document.getElementById('tabAdd');
        const tabList = document.getElementById('tabList');
        const viewAdd = document.getElementById('viewAdd');
        const viewList = document.getElementById('viewList');
        const bossNameInput = document.getElementById('bossName');
        const timeOfDeathInput = document.getElementById('timeOfDeath');
        const respawnIntervalInput = document.getElementById('respawnInterval');
        const addTimerBtn = document.getElementById('addTimerBtn');
        const formMessage = document.getElementById('formMessage');
        const bossListBody = document.getElementById('bossListBody');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const noBossesMessage = document.getElementById('noBossesMessage');

        // --- 2. Utility Functions ---

        // Function to set default TOD to current time
        const setInitialTOD = () => {
            try {
                const now = new Date();
                const localTime = new Date(now.getTime() - (now.getTimezoneOffset() * 60000));
                const formattedValue = localTime.toISOString().slice(0, 16);
                timeOfDeathInput.value = formattedValue;
            } catch (e) {
                console.error("Could not set initial datetime-local value:", e);
            }
        };

        // Function to format remaining time
        const formatRemainingTime = (spawnDate) => {
            const now = new Date();
            const diffMs = spawnDate.getTime() - now.getTime();
            
            if (diffMs <= 0) return { status: 'SPAWNED', color: 'text-red-400 font-bold' };

            const totalSeconds = Math.floor(diffMs / 1000); 
            
            const days = Math.floor(totalSeconds / (3600 * 24));
            const hours = Math.floor((totalSeconds % (3600 * 24)) / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);

            let parts = [];
            if (days > 0) parts.push(`${days}d`);
            if (hours > 0) parts.push(`${hours}h`);
            if (days === 0 && minutes > 0) parts.push(`${minutes}m`);
            if (days === 0 && totalSeconds < 60*60) parts.push(`${seconds}s`);

            // If only minutes/seconds are left, make sure it looks like a countdown
            if (parts.length === 0 && totalSeconds < 60) {
                 return { status: `${minutes}m ${seconds}s`, color: 'text-red-400 font-bold tracking-wider' };
            }

            if (parts.length === 0) return { status: '0s', color: 'text-red-400 font-bold' };
            
            return { status: parts.join(' '), color: 'text-yellow-400 font-bold tracking-wider' };
        };

        const displayMessage = (message, isError = false) => {
            formMessage.textContent = message;
            formMessage.classList.remove('hidden', 'bg-red-800/20', 'text-red-300', 'bg-green-800/20', 'text-green-300');
            if (isError) {
                formMessage.classList.add('bg-red-800/20', 'text-red-300');
            } else {
                formMessage.classList.add('bg-green-800/20', 'text-green-300');
            }
            setTimeout(() => formMessage.classList.add('hidden'), 5000);
        };

        // --- 3. Core Logic (Auth & Persistence) ---

        const initializeFirebase = async () => {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing.");
                    throw new Error("Initialization failed: Firebase configuration is empty.");
                }
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Auth check and silent sign-in (mandatory for Firestore access)
                await new Promise(resolve => {
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            // currentUserId = user.uid; // No longer storing this as a global variable
                            resolve();
                        } else {
                            // Sign in if no user is present
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        }
                    });
                });

                // Once auth is ready, set up the listener
                setupRealtimeListener();

            } catch (error) {
                console.error("Firebase initialization or authentication error:", error);
                loadingIndicator.textContent = 'Failed to load schedules.';
            }
        };

        const addBossTimer = async () => {
            if (!db) {
                displayMessage('System not ready. Please wait for initialization.', true);
                return;
            }

            const name = bossNameInput.value.trim();
            const todValue = timeOfDeathInput.value;
            const intervalHours = parseFloat(respawnIntervalInput.value);

            if (!name) {
                displayMessage('Boss name is required.', true);
                return;
            }
            if (!todValue) {
                displayMessage('Time of Death is required.', true);
                return;
            }
            if (isNaN(intervalHours) || intervalHours <= 0) {
                displayMessage('Respawn cycle must be a positive number of hours.', true);
                return;
            }

            try {
                addTimerBtn.disabled = true;
                addTimerBtn.textContent = 'Saving...';
                
                await addDoc(collection(db, bossesCollectionPath), {
                    name: name,
                    todTimestamp: new Date(todValue).toISOString(), // Store TOD as ISO string
                    intervalHours: intervalHours,
                    // Removed currentUserId field to simplify "free use" data structure
                    createdAt: new Date().toISOString()
                });

                displayMessage(`'${name}' timer added successfully!`, false);
                bossNameInput.value = '';
                respawnIntervalInput.value = '';
                setInitialTOD(); // Reset TOD to current time

            } catch (e) {
                console.error("Error adding document: ", e);
                displayMessage('Error saving timer. Check console.', true);
            } finally {
                addTimerBtn.disabled = false;
                addTimerBtn.innerHTML = '<i class="ph ph-plus-circle"></i> Save Boss Timer';
            }
        };

        const deleteBossTimer = async (docId) => {
            if (!db) return;
            try {
                await deleteDoc(doc(db, bossesCollectionPath, docId));
                // UI updates via onSnapshot
            } catch (e) {
                console.error("Error removing document: ", e);
            }
        };

        const resetBossTimer = async (docId) => {
            if (!db) return;
            try {
                // Set the new Time of Death to the current time (now)
                const newTodTimestamp = new Date().toISOString();
                
                await updateDoc(doc(db, bossesCollectionPath, docId), {
                    todTimestamp: newTodTimestamp
                });
                // UI updates via onSnapshot
            } catch (e) {
                console.error("Error resetting document: ", e);
            }
        };

        const renderBossList = (bosses) => {
            bossListBody.innerHTML = '';
            loadingIndicator.classList.add('hidden');

            if (bosses.length === 0) {
                noBossesMessage.classList.remove('hidden');
                return;
            }
            noBossesMessage.classList.add('hidden');

            // Sort bosses by next spawn time
            bosses.sort((a, b) => a.spawnDate.getTime() - b.spawnDate.getTime());

            bosses.forEach(boss => {
                const todDate = new Date(boss.todTimestamp);
                
                // Format TOD Date (less verbose for mobile)
                const formattedTOD = todDate.toLocaleString(undefined, { 
                    month: 'short', day: 'numeric', 
                    hour: '2-digit', minute: '2-digit', hour12: false 
                });

                // Format Spawn Date (verbose for clarity)
                const formattedSpawn = boss.spawnDate.toLocaleString(undefined, {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });

                const remainingTimeData = formatRemainingTime(boss.spawnDate);

                let bossStatus = '';
                let statusColor = '';
                let remainingDisplay = remainingTimeData.status;

                if (remainingTimeData.status === 'SPAWNED') {
                    // Boss is ready to be killed
                    bossStatus = 'ALIVE (Ready to Kill)'; // Boss has spawned
                    statusColor = 'text-green-400 font-bold';
                    remainingDisplay = '0s'; // Show 0s instead of SPAWNED in countdown column
                } else {
                    // Boss is on cooldown
                    bossStatus = 'DEAD (On Cooldown)'; // Boss is killed and counting down
                    statusColor = 'text-yellow-400 font-bold';
                    // remainingDisplay is already set by formatRemainingTime
                }

                const row = document.createElement('tr');
                row.className = 'result-row border-b border-gray-800';
                row.innerHTML = `
                    <td class="py-3 pr-2 font-semibold text-white truncate">${boss.name} <span class="text-xs text-gray-500 font-normal hidden sm:inline-block">(${boss.intervalHours}h)</span></td>
                    <td class="py-3 px-2 text-xs text-gray-400 hidden lg:table-cell">${formattedTOD}</td>
                    <td class="py-3 px-2 text-sm text-teal-400 font-medium">${formattedSpawn}</td>
                    <td class="py-3 px-2 text-center text-sm ${statusColor}">${bossStatus}</td>
                    <td class="py-3 px-2 text-center text-sm ${remainingTimeData.color}">${remainingDisplay}</td>
                    <td class="py-3 pl-2 flex justify-center space-x-2">
                        <button class="action-btn set-killed-btn p-2 text-gray-400 flex items-center" title="Set Killed (Reset Timer)" data-id="${boss.id}">
                            <i class="ph ph-crosshair text-lg"></i>
                            <span class="text-xs ml-1 hidden lg:inline">Set Killed</span>
                        </button>
                        <button class="action-btn delete-btn p-2 text-gray-400" title="Delete Timer" data-id="${boss.id}">
                            <i class="ph ph-trash-simple text-lg"></i>
                        </button>
                    </td>
                `;
                bossListBody.appendChild(row);
            });

            // Re-attach action listeners
            bossListBody.querySelectorAll('.set-killed-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const docId = e.currentTarget.getAttribute('data-id');
                    resetBossTimer(docId);
                });
            });

            bossListBody.querySelectorAll('.delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const docId = e.currentTarget.getAttribute('data-id');
                    deleteBossTimer(docId);
                });
            });
        };

        const setupRealtimeListener = () => {
            const bossQuery = collection(db, bossesCollectionPath);

            onSnapshot(bossQuery, (snapshot) => {
                const bosses = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const todDate = new Date(data.todTimestamp);
                    const spawnDate = new Date(todDate.getTime() + (data.intervalHours * 3600000)); // 3600000 ms in an hour

                    bosses.push({
                        id: doc.id,
                        ...data,
                        spawnDate: spawnDate // Calculated field for sorting/display
                    });
                });
                
                renderBossList(bosses);
                
                // Clear previous interval if it exists
                if (realtimeTimerInterval) {
                    clearInterval(realtimeTimerInterval);
                }
                
                // Start a new interval to update the "Remaining" countdown every second
                // Note: Only necessary if we are on the list view.
                realtimeTimerInterval = setInterval(() => {
                    if (!viewList.classList.contains('hidden')) {
                         renderBossList(bosses); 
                    }
                }, 1000); 
            }, (error) => {
                console.error("Firestore snapshot error: ", error);
                loadingIndicator.textContent = 'Error loading schedules.';
            });
        };

        // --- 4. Event Listeners & Initialization ---

        // Tab Switching Logic
        const switchTab = (tabName) => {
            tabAdd.classList.remove('active');
            tabList.classList.remove('active');
            viewAdd.classList.add('hidden');
            viewList.classList.add('hidden');

            if (tabName === 'add') {
                tabAdd.classList.add('active');
                viewAdd.classList.remove('hidden');
            } else if (tabName === 'list') {
                tabList.classList.add('active');
                viewList.classList.remove('hidden');
            }
        };

        tabAdd.addEventListener('click', () => switchTab('add'));
        tabList.addEventListener('click', () => switchTab('list'));
        addTimerBtn.addEventListener('click', addBossTimer);

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            setInitialTOD();
            switchTab('add'); // Set default view
            initializeFirebase();
        });
    </script>

</body>
</html>
